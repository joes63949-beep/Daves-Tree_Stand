const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const path = require("path");
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const fs = require("fs");
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const express = require("express");
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const helmet = require("helmet");
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const rateLimit = require("express-rate-limit");
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const sqlite3 = require("sqlite3").verbose();
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
require("dotenv").config();
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const app = express();
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const PORT = Number(process.env.PORT || 3000);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const ADMIN_TOKEN = process.env.ADMIN_TOKEN || "";
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const dataDir = path.join(__dirname, "data");
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
const db = new sqlite3.Database(dbPath);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
// Security basics
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.use(helmet({ contentSecurityPolicy: false })); // allow embedded map iframe
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.use(express.json({ limit: "200kb" }));
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.use(express.urlencoded({ extended: true }));
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.use(
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  rateLimit({
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    windowMs: 60 * 1000,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    max: 120
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  })
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
// Serve frontend
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.use(express.static(path.join(__dirname, "public")));
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
// --- helpers
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
function nowISO() {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  return new Date().toISOString();
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
}
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
function clampStr(s, max) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (typeof s !== "string") return "";
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const trimmed = s.trim();
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  return trimmed.length > max ? trimmed.slice(0, max) : trimmed;
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
}
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
function isEmail(s) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  return typeof s === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s.trim());
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
}
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
function isCategory(cat) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  return ["Reviews", "News", "WhatsNew"].includes(cat);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
}
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
// --- DB init
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
db.serialize(() => {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  db.run(`
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    CREATE TABLE IF NOT EXISTS preorders (
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      id INTEGER PRIMARY KEY AUTOINCREMENT,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      name TEXT NOT NULL,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      email TEXT NOT NULL,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      phone TEXT,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      delivery_address TEXT,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      product_type TEXT NOT NULL,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      tree_size TEXT,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      quantity INTEGER NOT NULL DEFAULT 1,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      notes TEXT,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      preferred_delivery_date TEXT,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      delivery_character TEXT,                 -- Standard | Santa | Grinch
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      want_installation INTEGER NOT NULL DEFAULT 1,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      decorating_notes TEXT,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      created_at TEXT NOT NULL
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    )
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  `);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  db.run(`
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    CREATE TABLE IF NOT EXISTS posts (
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      id INTEGER PRIMARY KEY AUTOINCREMENT,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      display_name TEXT NOT NULL,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      category TEXT NOT NULL,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      title TEXT NOT NULL,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      body TEXT NOT NULL,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      created_at TEXT NOT NULL
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    )
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  `);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
});
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
// --- API: preorders
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.post("/api/preorders", (req, res) => {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const name = clampStr(req.body.name, 80);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const email = clampStr(req.body.email, 120);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const phone = clampStr(req.body.phone, 40);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const delivery_address = clampStr(req.body.delivery_address, 200);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const product_type = clampStr(req.body.product_type, 40);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const tree_size = clampStr(req.body.tree_size, 20);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const quantity = Number(req.body.quantity || 1);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const notes = clampStr(req.body.notes, 500);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const preferred_delivery_date = clampStr(req.body.preferred_delivery_date, 40);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const delivery_character = clampStr(req.body.delivery_character || "Standard", 20);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const want_installation = req.body.want_installation ? 1 : 0;
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const decorating_notes = clampStr(req.body.decorating_notes || "", 500);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!name) return res.status(400).json({ ok: false, error: "Name is required." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!isEmail(email)) return res.status(400).json({ ok: false, error: "Valid email is required." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!product_type) return res.status(400).json({ ok: false, error: "Product type is required." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!Number.isFinite(quantity) || quantity < 1 || quantity > 20) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    return res.status(400).json({ ok: false, error: "Quantity must be 1â€“20." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  }
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const allowedCharacters = ["Standard", "Santa", "Grinch"];
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!allowedCharacters.includes(delivery_character)) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    return res.status(400).json({ ok: false, error: "Invalid delivery character choice." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  }
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const created_at = nowISO();
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  db.run(
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    `
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      INSERT INTO preorders
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
        (name, email, phone, delivery_address, product_type, tree_size, quantity, notes, preferred_delivery_date,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
         delivery_character, want_installation, want_tree_removal, want_tree_decorating, decorating_notes,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
         created_at)
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      VALUES
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
        (?, ?, ?, ?, ?, ?, ?, ?, ?,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
         ?, ?, ?, ?, ?,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
         ?)
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    `,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    [
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      name,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      email,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      phone,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      delivery_address,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      product_type,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      tree_size,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      quantity,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      notes,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      preferred_delivery_date,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      delivery_character,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      want_installation,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      want_tree_removal,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      want_tree_decorating,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      decorating_notes,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      created_at
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    ],
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    function (err) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      if (err) return res.status(500).json({ ok: false, error: "Database error." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      return res.json({ ok: true, id: this.lastID });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    }
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  );
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
});
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
// --- API: posts list (forum)
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.get("/api/posts", (req, res) => {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const category = clampStr(req.query.category || "All", 20);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const q = clampStr(req.query.q || "", 80).toLowerCase();
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const limit = Math.min(Math.max(Number(req.query.limit || 20), 1), 50);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const offset = Math.max(Number(req.query.offset || 0), 0);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const params = [];
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  let where = "WHERE 1=1";
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (category !== "All") {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    if (!isCategory(category)) return res.status(400).json({ ok: false, error: "Invalid category." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    where += " AND category = ?";
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    params.push(category);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  }
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (q) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    where += " AND (LOWER(title) LIKE ? OR LOWER(body) LIKE ? OR LOWER(display_name) LIKE ?)";
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    const like = `%${q}%`;
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    params.push(like, like, like);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  }
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const sql = `
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    SELECT id, display_name, category, title, body, created_at
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    FROM posts
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    ${where}
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    ORDER BY datetime(created_at) DESC
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    LIMIT ? OFFSET ?
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  `;
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  db.all(sql, [...params, limit, offset], (err, rows) => {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    if (err) return res.status(500).json({ ok: false, error: "Database error." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    return res.json({ ok: true, items: rows });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
});
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
// --- API: create post
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.post("/api/posts", (req, res) => {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const display_name = clampStr(req.body.display_name, 40) || "Anonymous Elf";
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const category = clampStr(req.body.category, 20);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const title = clampStr(req.body.title, 90);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const body = clampStr(req.body.body, 1000);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!isCategory(category)) return res.status(400).json({ ok: false, error: "Choose a valid category." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!title) return res.status(400).json({ ok: false, error: "Title is required." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (body.length < 5) return res.status(400).json({ ok: false, error: "Message is too short." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const created_at = nowISO();
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  db.run(
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?, ?, ?, ?, ?)`,
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    [display_name, category, title, body, created_at],
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    function (err) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      if (err) return res.status(500).json({ ok: false, error: "Database error." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
      return res.json({ ok: true, id: this.lastID });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    }
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  );
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
});
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
// Optional admin delete (requires ADMIN_TOKEN)
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.delete("/api/posts/:id", (req, res) => {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!ADMIN_TOKEN) return res.status(403).json({ ok: false, error: "Admin not configured." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const token = String(req.headers["x-admin-token"] || "");
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (token !== ADMIN_TOKEN) return res.status(403).json({ ok: false, error: "Forbidden." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  const id = Number(req.params.id);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  if (!Number.isFinite(id)) return res.status(400).json({ ok: false, error: "Invalid id." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  db.run(`DELETE FROM posts WHERE id = ?`, [id], function (err) {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    if (err) return res.status(500).json({ ok: false, error: "Database error." });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
    return res.json({ ok: true, deleted: this.changes });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  });
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
});
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.get("/api/health", (_req, res) => res.json({ ok: true }));
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});

const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
app.listen(PORT, () => {
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
});
const path = require("path");
const fs = require("fs");
const express = require("express");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const sqlite3 = require("sqlite3").verbose();
require("dotenv").config();

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || "").trim();

const dataDir = path.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });

const dbPath = path.join(dataDir, "daves-tree-stand.sqlite");
const db = new sqlite3.Database(dbPath);

// Middleware
app.use(helmet({ contentSecurityPolicy: false })); // allow map iframe
app.use(express.json({ limit: "400kb" }));
app.use(express.urlencoded({ extended: true }));

app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 150
  })
);

// Static files
app.use(express.static(path.join(__dirname, "public")));

// Helpers
function nowISO() {
  return new Date().toISOString();
}
function s(v, max = 200) {
  if (typeof v !== "string") return "";
  const t = v.trim();
  return t.length > max ? t.slice(0, max) : t;
}
function isEmail(v) {
  return typeof v === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v.trim());
}
function toInt(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}
function pickCategory(v) {
  const x = s(v, 20);
  if (x === "Reviews" || x === "News" || x === "WhatsNew") return x;
  return "";
}
function ok(res, payload) {
  res.json({ ok: true, ...payload });
}
function bad(res, code, msg) {
  res.status(code).json({ ok: false, error: msg });
}

// DB init
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS preorders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT,
      product_type TEXT NOT NULL,
      tree_size TEXT,
      quantity INTEGER NOT NULL DEFAULT 1,
      delivery_character TEXT,
      preferred_delivery_date TEXT,
      delivery_address TEXT,
      want_installation INTEGER NOT NULL DEFAULT 1,
      want_tree_decorating INTEGER NOT NULL DEFAULT 0,
      want_tree_removal INTEGER NOT NULL DEFAULT 0,
      decorating_notes TEXT,
      notes TEXT,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      display_name TEXT NOT NULL,
      category TEXT NOT NULL,
      title TEXT NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT NOT NULL
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)`);
  db.run(`CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)`);
});

// Health
app.get("/api/health", (_req, res) => ok(res, { time: nowISO() }));

// Create preorder
app.post("/api/preorders", (req, res) => {
  const name = s(req.body.name, 80);
  const email = s(req.body.email, 120);
  const phone = s(req.body.phone, 40);

  const product_type = s(req.body.product_type, 40) || "Tree";
  const tree_size = s(req.body.tree_size, 20);
  const quantity = toInt(req.body.quantity, 1);

  const delivery_character = s(req.body.delivery_character, 20) || "Standard";
  const preferred_delivery_date = s(req.body.preferred_delivery_date, 40);
  const delivery_address = s(req.body.delivery_address, 200);

  const want_installation = req.body.want_installation ? 1 : 0;
  const want_tree_decorating = req.body.want_tree_decorating ? 1 : 0;
  const want_tree_removal = req.body.want_tree_removal ? 1 : 0;
  const decorating_notes = s(req.body.decorating_notes, 500);

  const notes = s(req.body.notes, 500);

  if (!name) return bad(res, 400, "Name is required.");
  if (!isEmail(email)) return bad(res, 400, "Valid email is required.");
  if (quantity < 1 || quantity > 20) return bad(res, 400, "Quantity must be between 1 and 20.");

  const allowedDelivery = new Set(["Standard", "Santa", "Grinch"]);
  if (!allowedDelivery.has(delivery_character)) return bad(res, 400, "Invalid delivery character.");

  const created_at = nowISO();

  db.run(
    `
    INSERT INTO preorders
    (name, email, phone, product_type, tree_size, quantity, delivery_character,
     preferred_delivery_date, delivery_address, want_installation,
     want_tree_decorating, want_tree_removal, decorating_notes, notes, created_at)
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    `,
    [
      name,
      email,
      phone,
      product_type,
      tree_size,
      quantity,
      delivery_character,
      preferred_delivery_date,
      delivery_address,
      want_installation,
      want_tree_decorating,
      want_tree_removal,
      decorating_notes,
      notes,
      created_at
    ],
    function (err) {
      if (err) return bad(res, 500, "Database error saving preorder.");
      ok(res, { id: this.lastID });
    }
  );
});

// Optional admin: list preorders (requires ADMIN_TOKEN if set)
app.get("/api/admin/preorders", (req, res) => {
  if (ADMIN_TOKEN) {
    const auth = (req.headers.authorization || "").trim();
    if (auth !== `Bearer ${ADMIN_TOKEN}`) return bad(res, 401, "Unauthorized.");
  }

  db.all(
    `SELECT * FROM preorders ORDER BY datetime(created_at) DESC LIMIT 200`,
    [],
    (err, rows) => {
      if (err) return bad(res, 500, "Database error reading preorders.");
      ok(res, { rows });
    }
  );
});

// Create post
app.post("/api/posts", (req, res) => {
  const display_name = s(req.body.display_name || "Anonymous", 40) || "Anonymous";
  const category = pickCategory(req.body.category);
  const title = s(req.body.title, 90);
  const body = s(req.body.body, 1000);

  if (!category) return bad(res, 400, "Category is required.");
  if (!title) return bad(res, 400, "Title is required.");
  if (!body) return bad(res, 400, "Message is required.");

  const created_at = nowISO();

  db.run(
    `INSERT INTO posts (display_name, category, title, body, created_at) VALUES (?,?,?,?,?)`,
    [display_name, category, title, body, created_at],
    function (err) {
      if (err) return bad(res, 500, "Database error saving post.");
      ok(res, { id: this.lastID });
    }
  );
});

// List posts with filter/search/pagination
app.get("/api/posts", (req, res) => {
  const category = s(req.query.category || "All", 20);
  const q = s(req.query.q || "", 80);
  const page = Math.max(1, toInt(req.query.page, 1));
  const pageSize = Math.min(20, Math.max(5, toInt(req.query.pageSize, 8)));
  const offset = (page - 1) * pageSize;

  const where = [];
  const params = [];

  if (category && category !== "All") {
    if (!["Reviews", "News", "WhatsNew"].includes(category)) {
      return bad(res, 400, "Invalid category.");
    }
    where.push("category = ?");
    params.push(category);
  }

  if (q) {
    where.push("(title LIKE ? OR body LIKE ? OR display_name LIKE ?)");
    params.push(`%${q}%`, `%${q}%`, `%${q}%`);
  }

  const whereSQL = where.length ? `WHERE ${where.join(" AND ")}` : "";

  db.get(
    `SELECT COUNT(*) as total FROM posts ${whereSQL}`,
    params,
    (err, countRow) => {
      if (err) return bad(res, 500, "Database error counting posts.");

      db.all(
        `
        SELECT id, display_name, category, title, body, created_at
        FROM posts
        ${whereSQL}
        ORDER BY datetime(created_at) DESC
        LIMIT ? OFFSET ?
        `,
        [...params, pageSize, offset],
        (err2, rows) => {
          if (err2) return bad(res, 500, "Database error reading posts.");
          ok(res, {
            page,
            pageSize,
            total: countRow.total,
            rows
          });
        }
      );
    }
  );
});

// Fallback to homepage
app.get("*", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.listen(PORT, () => {
  console.log(`ðŸŽ„ Dave's Tree Stand running at http://localhost:${PORT}`);
});
